package main

import (
	"bytes"
	"flag"
	"fmt"
	"github.com/aurelien-rainone/go-gencon/containers"
	"go/format"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

var (
	containee = flag.String("type", "", "type name of the containee; must be set")
	container = flag.String("cont", "", "type of the generic container; must be set")
	name      = flag.String("name", "", "override container name; default ContaineeContainer")
	output    = flag.String("output", "", "output file name; default srcdir/<type>_string.go")
	pkg       = flag.String("pkg", "", "package name of the generated file; only for cli usage")
)

// Usage is a replacement usage function for the flags package.
func Usage() {
	fmt.Fprintf(os.Stderr, "Usage of %s with go generate:\n", os.Args[0])
	fmt.Fprintf(os.Stderr, "\tgo-gencon [flags] -type containee -cont container\n")
	fmt.Fprintf(os.Stderr, "To use %s on the command line -pkg must be provided\n", os.Args[0])
	fmt.Fprintf(os.Stderr, "Available generic containers:\n")
	fmt.Fprintf(os.Stderr, " - Stack")
	fmt.Fprintf(os.Stderr, " - BoundedStack")
	fmt.Fprintf(os.Stderr, "For more information, see:\n")
	fmt.Fprintf(os.Stderr, "\thttp://github.com/aurelien-rainone/go-gencon\n")
	fmt.Fprintf(os.Stderr, "Flags:\n")
	flag.PrintDefaults()
}

func main() {

	log.SetFlags(0)
	log.SetPrefix("go-gencon: ")
	flag.Usage = Usage
	flag.Parse()

	if os.Getenv("GOPACKAGE") != "" {
		*pkg = os.Getenv("GOPACKAGE")
	}

	if *container == "" || *container == "" || *pkg == "" {
		flag.Usage()
		os.Exit(2)
	}

	var (
		g    Generator // generator instance
		cter string    // type name of generate container
	)
	// TODO: string manipulation
	// TODO: string manipulation
	// TODO: string manipulation
	//cter = strings.ToUpper((*containee)[0]) + *containee[1:] + *container
	cter = *containee + *container
	if len(*name) > 0 {
		cter = *name
	}
	g.nfo = FileInfo{*containee, cter, pkg}
	g.contType = *container
	g.Printf(fmt.Sprintln("//", "$GOPACKAGE", os.Getenv("GOPACKAGE")))

	wd, _ := os.Getwd()
	g.Printf(fmt.Sprintln("//", "Getwd()", wd))
	g.Printf(fmt.Sprintln("//", "$GOFILE", os.Getenv("GOFILE")))
	g.Printf(fmt.Sprintln("//", "$GOPACKAGE", os.Getenv("GOPACKAGE")))

	// Print the header and package clause.
	g.Printf("// Code generated by \"go-gencon %s\"; DO NOT EDIT\n", strings.Join(os.Args[1:], " "))
	g.Printf("\n")
	g.Printf("\n")

	// Format the output.
	src := g.format()

	if *output == "" {
		// generate output filename
		baseName := fmt.Sprintf("%s_%s.go", *containee, *container)
		*output = filepath.Join(".", strings.ToLower(baseName))
	}
	err := ioutil.WriteFile(*output, src, 0644)
	if err != nil {
		log.Fatalf("writing output: %s", err)
	}

}

// Generator holds the state of the analysis. Primarily used to buffer
// the output for format.Source.
type Generator struct {
	buf      bytes.Buffer // Accumulated output.
	nfo      FileInfo     // Info needed to the generated file
	contType string       // container to generate
}

type FileInfo struct {
	Containee, Container, Package string
}

func (g *Generator) Printf(format string, args ...interface{}) {
	fmt.Fprintf(&g.buf, format, args...)
}

// format returns the gofmt-ed contents of the Generator's buffer.
func (g *Generator) format() []byte {
	// list supported containers
	containers := map[string]string{
		"boundedstack": containers.BoundedStack,
	}

	// create container template
	var (
		tmpl  *template.Template
		str   string
		err   error
		found bool
	)
	if str, found = containers[strings.ToLower(g.contType)]; !found {
		log.Fatalf("No template for container '%s'", g.contType)
	}
	if tmpl, err = template.New(g.contType).Parse(str); err != nil {
		panic(err)
	}
	err = tmpl.Execute(&g.buf, g.nfo)
	if err != nil {
		panic(err)
	}

	src, err := format.Source(g.buf.Bytes())
	if err != nil {
		// Should never happen, but can arise when developing this code.
		// The user can compile the output to see the error.
		log.Printf("warning: internal error: invalid Go generated: %s", err)
		log.Printf("warning: compile the package to analyze the error")
		return g.buf.Bytes()
	}
	return src
}
